### 继承
1. 子类继承父类  子类构造函数里第一行执行super()；代表运行父类的构造函数。  super. 可以获取父类的方法和变量
### 抽象类
1. 抽象类不能直接new，必须重写覆盖抽象类中的所有抽象方法
### 接口
1. 定义接口
```
public interface 接口名称 {
  // 接口内容
}
```
2. 接口内容可以包含： java7 常量  抽象方法、 java8 默认方法 静态方法  、java9 私有方法
3. 抽象方法：
```
public interface MyInterfaceAbstract {
  public abstract void fn();
  // public 和abstract都可以省略。
}
```
4. 实现类来实现接口的使用, 必须覆盖重写接口中所有抽象方法：
```
  public class 实现类名称 implements 接口名 {
    public void fn() {}
  }
```
5. java8 默认方法：
```
public default 返回值类型 方法名() {
  // 用来解决接口升级。 因为默认方法不用重写，不覆盖抽象方法的话，就不会报错
  // 实现类中不用写， 只用在接口中增加， 实例中直接调用
}
```
6. java8 静态方法(不能通过实现类的对象调用，应该通过[接口名.]直接调用)
```
  public static 返回值类型 方法名() {
    // 
  }
```
7. java9 私有方法（只能在接口类中使用）
一、普通, 供默认方法调用
```
private ...
```
二、静态， 供静态方法调用
```
private static ...
```
8. 常量  （赋值后不可改变,最好大写，用下划线分割，可以直接用接口名.来访问）
```
 public static final int AAA_BBB = 1;
 // public static final 可以省略
```
9. 接口没有静态代码块和构造函数， 一个类可以同时实现多个接口
10. 接口可以多继承
### 多态
1. 类向上转型：左父 右子  就是多态，即是父亲，也是儿子。子类的成员变量是没用的，比父类多余的方法也是没用的。好处：不是很明白。只不过换了种写法
2. 类向下转型：父类转化成子类（不一定安全,用instanceof判断是哪个类的对象）

### final关键字
1. 修饰类 不能有子类，最终的类，断子绝孙，所有方法都不能重写，太监
2. 修饰局部变量 不能改变的最终，只能赋值一次，引用类型的地址不可改变
3. 修饰成员变量 不能改变的最终变量，直接赋值 或者构造函数里赋值 只能赋值一次
4. 修饰成员方法 不能重写的最终方法

### 权限修饰符
public > protected（不同包的子类可以） > (default)（同一个包都可以） > private(只能本类)

### 内部类
1. 成员内部类
2. 局部内部类
3. 匿名内部类（属于局部）

